# ESPHome Configuration for Everything Presence One (EP1)
# Modified for Motion-Activated Lighting with Brightness Filtering
# Part of the Home Assistant motion lighting solution
# Repository: [Your GitHub URL]

# ============================================
# SUBSTITUTIONS
# ============================================
# Customize these values for each sensor

substitutions:
  name: "ep1corridio"
  room: "EP1 Corridio"
  friendly_name: "${room}"
  project_name: "Everything Smart Technology.Everything Presence One"
  project_version: "1.2.7s"
  
  # Sensor calibration offsets
  temperature_offset: "-3"
  humidity_offset: "5"
  
  # Update intervals
  temperature_update_interval: "60s"
  illuminance_update_interval: "30s"
  
  # Delay settings
  pir_delay_off: "0s"
  occupancy_delay_off: "0s"
  
  # Feature flags
  hidden_ssid: "false"
  factory_reset_disabled: "true"
  uart_target_output_disabled: "true"
  uart_presence_output_disabled: "true"

# ============================================
# BASIC CONFIGURATION
# ============================================

esphome:
  name: "${name}"
  on_boot:
    priority: -100
    then:
      - uart.write: "sensorStart"

esp32:
  board: esp32dev

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${room} Fallback Hotspot"
    password: !secret fallback_password

captive_portal:

web_server:

improv_serial:

# ============================================
# STATUS LED
# ============================================

light:
  - platform: status_led
    name: "ESP32 Status LED"
    pin: GPIO32
    entity_category: config

# ============================================
# I2C BUS
# ============================================

i2c:
  sda: 26
  scl: 25
  scan: true

# ============================================
# SENSORS
# ============================================

sensor:
  # Temperature and Humidity Sensor (SHTC3)
  - platform: shtcx
    temperature:
      name: "${room} Temperature"
      filters:
        - lambda: return x + id(temperature_offset_input).state;
    humidity:
      name: "${room} Humidity"
      filters:
        - lambda: return x + id(humidity_offset_input).state;
    address: 0x70
    update_interval: ${temperature_update_interval}
  
  # Light Sensor (BH1750) with calibration
  - platform: bh1750
    name: "${room} Illuminance"
    id: bh1750_sensor
    address: 0x23
    update_interval: ${illuminance_update_interval}
    filters:
      # Calibration curve - adjust based on your sensor
      - calibrate_linear:
          method: exact
          datapoints:
            - 0.1 -> 0.3
            - 0.3 -> 0.6
            - 0.9 -> 1.7
            - 1.2 -> 3.6
            - 3.2 -> 6.9
            - 5.1 -> 10.2
            - 6.8 -> 27.1
            - 7.0 -> 13.5
            - 7.4 -> 28.2
            - 8.7 -> 21.7
            - 8.9 -> 17.1
            - 10.9 -> 20.4
            - 12.8 -> 23.5
            - 14.5 -> 31.2
            - 14.9 -> 26.7
            - 16.8 -> 41.1
            - 16.9 -> 30.2
            - 18.8 -> 33.4
            - 19.1 -> 35.8
            - 20.7 -> 37.0
            - 24.3 -> 60.3
            - 26.1 -> 68.6
            - 26.7 -> 83.8
            - 30.2 -> 75.9
            - 32.6 -> 80.3
            - 34.6 -> 83.2
            - 40.4 -> 99.9
            - 48.0 -> 183.7
            - 48.3 -> 119.2
            - 55.5 -> 141.3
            - 55.8 -> 137.9
            - 63.8 -> 157.6
            - 71.5 -> 176.9
            - 79.8 -> 197.1
            - 84.3 -> 205.7
      - clamp:
          min_value: 0

# ============================================
# BINARY SENSORS (OCCUPANCY DETECTION)
# ============================================
# This is the key modification for motion-activated lighting

binary_sensor:
  # mmWave Sensor (LD2410)
  - platform: gpio
    name: ${room} mmWave
    id: mmwave
    device_class: occupancy
    pin:
      number: GPIO17
      mode: INPUT_PULLDOWN
  
  # PIR Sensor
  - platform: gpio
    pin:
      number: 33
      mode: INPUT_PULLDOWN
    name: ${room} PIR
    id: pir_motion_sensor
    device_class: motion
    filters:
      - delayed_off: ${pir_delay_off}
  
  # Combined Occupancy Sensor (Raw)
  # Combines PIR and mmWave - useful for security/away detection
  - platform: template
    name: ${room} Occupancy Raw
    id: occupancy_raw
    device_class: occupancy
    filters:
      - delayed_off: ${occupancy_delay_off}
    lambda: |-
      if (id(mmwave).state or id(pir_motion_sensor).state) {
        return true;
      } 
      else if (id(mmwave).state == 0 and id(pir_motion_sensor).state == 0) {
        return false;
      } 
      else {
        return id(occupancy_raw).state;
      }

  # Filtered Occupancy Sensor
  # KEY MODIFICATION: Only triggers if brightness is below threshold
  # This prevents lights turning on when room is already bright
  - platform: template
    name: ${room} Occupancy Filtered
    id: occupancy_filtered
    device_class: occupancy
    lambda: |-
      static bool last_occupancy_state = false;
      static bool filtered_state = false;
      bool current_occupancy = id(occupancy_raw).state;
      
      // When occupancy goes from off to on, check brightness immediately
      if (current_occupancy && !last_occupancy_state) {
        // Only set filtered state to true if room is darker than threshold
        filtered_state = id(bh1750_sensor).state < id(occupancy_brightness_threshold).state ? true : false;
      } else if (!current_occupancy) {
        // When no occupancy, always set to false
        filtered_state = false;
      }
      last_occupancy_state = current_occupancy;
      return filtered_state;

# ============================================
# CONFIGURATION NUMBERS
# ============================================

number:
  # Temperature calibration offset
  - platform: template
    name: "Temperature Offset"
    id: temperature_offset_input
    min_value: -10
    max_value: 5
    step: 0.1
    unit_of_measurement: 'Â°C'
    mode: box
    optimistic: true
    initial_value: ${temperature_offset}
    restore_value: true
    entity_category: config

  # Humidity calibration offset
  - platform: template
    name: "Humidity Offset"
    id: humidity_offset_input
    min_value: -30
    max_value: 30
    step: 0.1
    unit_of_measurement: '%'
    mode: box
    optimistic: true
    initial_value: ${humidity_offset}
    restore_value: true
    entity_category: config

  # Brightness threshold for filtered occupancy sensor
  # IMPORTANT: Adjust this value based on your room and preferences
  - platform: template
    name: "Occupancy Brightness Threshold"
    id: occupancy_brightness_threshold
    min_value: 0
    max_value: 80.0
    step: 0.1
    unit_of_measurement: 'lx'
    mode: box
    optimistic: true
    initial_value: 20.0
    restore_value: true
    entity_category: config

  # mmWave sensor configuration
  - platform: template
    name: mmWave Min Distance
    id: mmwave_min_distance
    entity_category: config
    min_value: 0
    max_value: 2500
    initial_value: 0
    optimistic: true
    step: 10
    restore_value: true
    unit_of_measurement: cm
    mode: slider
    set_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: !lambda
          int min = id(mmwave_min_distance).state / 100;
          int max = id(mmwave_distance).state / 100;
          std::string ms = "setRange " + to_string(min) + " " + to_string(max);
          return std::vector<unsigned char>(ms.begin(), ms.end());
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 1s
      - switch.turn_on: mmwave_sensor

  - platform: template
    name: mmWave Distance
    id: mmwave_distance
    entity_category: config
    min_value: 0
    max_value: 2500
    initial_value: 300
    optimistic: true
    step: 10
    restore_value: true
    unit_of_measurement: cm
    mode: slider
    set_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: !lambda
          int min = id(mmwave_min_distance).state / 100;
          int max = id(mmwave_distance).state / 100;
          std::string ms = "setRange " + to_string(min) + " " + to_string(max);
          return std::vector<unsigned char>(ms.begin(), ms.end());
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 1s
      - switch.turn_on: mmwave_sensor

  - platform: template
    name: mmWave Off Latency
    id: mmwave_off_latency
    entity_category: config
    min_value: 1
    max_value: 60
    initial_value: 15
    optimistic: true
    step: 1
    restore_value: true
    unit_of_measurement: seconds
    mode: slider
    set_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: !lambda |-
          std::string mss = "setLatency " + to_string(id(mmwave_on_latency).state) + " " + to_string(id(mmwave_off_latency).state);
          return std::vector<unsigned char>(mss.begin(), mss.end());
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 1s
      - switch.turn_on: mmwave_sensor

  - platform: template
    name: mmWave On Latency
    id: mmwave_on_latency
    entity_category: config
    min_value: 0
    max_value: 60
    initial_value: 0
    optimistic: true
    step: 0.5
    restore_value: true
    unit_of_measurement: seconds
    mode: slider
    set_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: !lambda |-
          std::string mss = "setLatency " + to_string(id(mmwave_on_latency).state) + " " + to_string(id(mmwave_off_latency).state);
          return std::vector<unsigned char>(mss.begin(), mss.end());
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 1s
      - switch.turn_on: mmwave_sensor

  - platform: template
    id: mmwave_range_reduced
    name: mmWave Range Reduced
    icon: mdi:arrow-left-right
    entity_category: config
    min_value: 0
    max_value: 25
    initial_value: 0.8
    optimistic: true
    step: 0.1
    restore_value: true
    unit_of_measurement: m
    mode: slider
    set_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: !lambda
          std::string ms = "setRangeReduced " + to_string(x);
          return std::vector<unsigned char>(ms.begin(), ms.end());
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 1s
      - switch.turn_on: mmwave_sensor

  - platform: template
    name: mmWave Sensitivity
    id: mmwave_sensitivity
    entity_category: config
    min_value: 0
    max_value: 9
    initial_value: 7
    optimistic: true
    step: 1
    restore_value: true
    set_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write:
          !lambda std::string mss = "setSensitivity " + to_string(id(mmwave_sensitivity).state) + " " + to_string(id(mmwave_trigger_sensitivity).state);
          return std::vector<unsigned char>(mss.begin(), mss.end());
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 1s
      - switch.turn_on: mmwave_sensor

  - platform: template
    name: mmWave Trigger Sensitivity
    icon: mdi:target-variant
    id: mmwave_trigger_sensitivity
    entity_category: config
    min_value: 0
    max_value: 9
    initial_value: 5
    optimistic: true
    step: 1
    restore_value: true
    set_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write:
          !lambda std::string mss = "setSensitivity " + to_string(id(mmwave_sensitivity).state) + " " + to_string(id(mmwave_trigger_sensitivity).state);
          return std::vector<unsigned char>(mss.begin(), mss.end());
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 1s
      - switch.turn_on: mmwave_sensor

# ============================================
# UART (mmWave Sensor Communication)
# ============================================

uart:
  id: uart_bus
  tx_pin: GPIO14
  rx_pin: GPIO13
  baud_rate: 9600
  debug:
    direction: BOTH
    dummy_receiver: true
    after:
      delimiter: "\\n"
    sequence:
      - lambda: UARTDebug::log_string(direction, bytes);

# ============================================
# SWITCHES
# ============================================

switch:
  - platform: template
    name: "mmWave Sensor"
    id: "mmwave_sensor"
    entity_category: config
    optimistic: true
    restore_mode: DISABLED
    turn_on_action:
      - uart.write: "sensorStart"
      - delay: 1s
    turn_off_action:
      - uart.write: "sensorStop"
      - delay: 1s

  - platform: template
    name: "mmWave LED"
    id: "mmwave_led"
    entity_category: config
    optimistic: true
    restore_mode: DISABLED
    turn_on_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: "setLedMode 1 0"
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 3s
      - switch.turn_on: mmwave_sensor
    turn_off_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: "setLedMode 1 1"
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 3s
      - switch.turn_on: mmwave_sensor

  - platform: template
    name: "uart_presence_output"
    id: "uart_presence_output"
    entity_category: config
    internal: ${uart_presence_output_disabled}
    optimistic: true
    turn_on_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: "setUartOutput 1 1"
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 3s
      - switch.turn_on: mmwave_sensor
    turn_off_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: "setUartOutput 1 0"
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 3s
      - switch.turn_on: mmwave_sensor

  - platform: template
    name: "uart_target_output"
    id: "uart_target_output"
    entity_category: config
    internal: ${uart_target_output_disabled}
    optimistic: true
    assumed_state: false
    turn_on_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: "setUartOutput 2 1 1 1"
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 3s
      - switch.turn_on: mmwave_sensor
    turn_off_action:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: "setUartOutput 2 0"
      - delay: 1s
      - uart.write: "saveConfig"
      - delay: 3s
      - switch.turn_on: mmwave_sensor

# ============================================
# BUTTONS
# ============================================

button:
  - platform: restart
    name: Restart_internal
    id: restart_internal
    entity_category: config 
    internal: true
    
  - platform: template
    name: "Restart mmWave Sensor"
    id: "restart_mmwave"
    entity_category: config
    internal: true
    on_press:
      - uart.write: "resetSystem"
      
  - platform: template
    name: Restart $name
    entity_category: config
    on_press:
      - button.press: restart_mmwave
      - button.press: restart_internal
      
  - platform: safe_mode
    internal: false
    name: $name Safe Mode
    entity_category: config
    
  - platform: template
    name: "Factory Reset mmWave"
    id: "factory_reset_mmwave"
    internal: ${factory_reset_disabled}
    entity_category: config
    on_press:
      - switch.turn_off: mmwave_sensor
      - delay: 1s
      - uart.write: "resetCfg"
      - delay: 3s
      - switch.turn_on: mmwave_sensor
